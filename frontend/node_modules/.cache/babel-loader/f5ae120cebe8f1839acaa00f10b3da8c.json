{"ast":null,"code":"/*\n * The Original Code is Mozilla Universal charset detector code.\n *\n * The Initial Developer of the Original Code is\n * Netscape Communications Corporation.\n * Portions created by the Initial Developer are Copyright (C) 2001\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *   AntÃ³nio Afonso (antonio.afonso gmail.com) - port to JavaScript\n *   Mark Pilgrim - port to Python\n *   Shy Shalom - original C code\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301  USA\n */\n\n/**\n * This is a port from the python port, version \"2.0.1\"\n */\nvar constants = require('./constants');\n\nvar MBCSGroupProber = require('./mbcsgroupprober');\n\nvar SBCSGroupProber = require('./sbcsgroupprober');\n\nvar Latin1Prober = require('./latin1prober');\n\nvar EscCharSetProber = require('./escprober');\n\nvar logger = require('./logger');\n\nfunction UniversalDetector(options) {\n  if (!options) options = {};\n  if (!options.minimumThreshold) options.minimumThreshold = 0.20;\n  var _state = {\n    pureAscii: 0,\n    escAscii: 1,\n    highbyte: 2\n  };\n  var self = this;\n\n  function init() {\n    self._highBitDetector = /[\\x80-\\xFF]/;\n    self._escDetector = /(\\x1B|~\\{)/;\n    self._mEscCharsetProber = null;\n    self._mCharsetProbers = [];\n    self.reset();\n  }\n\n  this.reset = function () {\n    this.result = {\n      \"encoding\": null,\n      \"confidence\": 0.0\n    };\n    this.results = [];\n    this.done = false;\n    this._mStart = true;\n    this._mGotData = false;\n    this._mInputState = _state.pureAscii;\n    this._mLastChar = \"\";\n    this._mBOM = \"\";\n\n    if (this._mEscCharsetProber) {\n      this._mEscCharsetProber.reset();\n    }\n\n    for (var i = 0, prober; prober = this._mCharsetProbers[i]; i++) {\n      prober.reset();\n    }\n  };\n\n  this.feed = function (aBuf) {\n    if (this.done) return;\n    var aLen = aBuf.length;\n    if (!aLen) return;\n\n    if (!this._mGotData) {\n      this._mBOM += aBuf; // If the data starts with BOM, we know it is UTF\n\n      if (this._mBOM.slice(0, 3) == \"\\xEF\\xBB\\xBF\") {\n        // EF BB BF  UTF-8 with BOM\n        this.result = {\n          \"encoding\": \"UTF-8\",\n          \"confidence\": 1.0\n        };\n      } else if (this._mBOM.slice(0, 4) == \"\\xFF\\xFE\\x00\\x00\") {\n        // FF FE 00 00  UTF-32, little-endian BOM\n        this.result = {\n          \"encoding\": \"UTF-32LE\",\n          \"confidence\": 1.0\n        };\n      } else if (this._mBOM.slice(0, 4) == \"\\x00\\x00\\xFE\\xFF\") {\n        // 00 00 FE FF  UTF-32, big-endian BOM\n        this.result = {\n          \"encoding\": \"UTF-32BE\",\n          \"confidence\": 1.0\n        };\n      } else if (this._mBOM.slice(0, 4) == \"\\xFE\\xFF\\x00\\x00\") {\n        // FE FF 00 00  UCS-4, unusual octet order BOM (3412)\n        this.result = {\n          \"encoding\": \"X-ISO-10646-UCS-4-3412\",\n          \"confidence\": 1.0\n        };\n      } else if (this._mBOM.slice(0, 4) == \"\\x00\\x00\\xFF\\xFE\") {\n        // 00 00 FF FE  UCS-4, unusual octet order BOM (2143)\n        this.result = {\n          \"encoding\": \"X-ISO-10646-UCS-4-2143\",\n          \"confidence\": 1.0\n        };\n      } else if (this._mBOM.slice(0, 2) == \"\\xFF\\xFE\") {\n        // FF FE  UTF-16, little endian BOM\n        this.result = {\n          \"encoding\": \"UTF-16LE\",\n          \"confidence\": 1.0\n        };\n      } else if (this._mBOM.slice(0, 2) == \"\\xFE\\xFF\") {\n        // FE FF  UTF-16, big endian BOM\n        this.result = {\n          \"encoding\": \"UTF-16BE\",\n          \"confidence\": 1.0\n        };\n      }\n\n      if (this.result.confidence > 0) {\n        this.results = [this.result];\n      } // If we got to 4 chars without being able to detect a BOM we\n      // stop trying.\n\n\n      if (this._mBOM.length > 3) {\n        this._mGotData = true;\n      }\n    }\n\n    if (this.result.encoding && this.result.confidence > 0.0) {\n      this.done = true;\n      return;\n    }\n\n    if (this._mInputState == _state.pureAscii) {\n      if (this._highBitDetector.test(aBuf)) {\n        this._mInputState = _state.highbyte;\n      } else if (this._escDetector.test(this._mLastChar + aBuf)) {\n        this._mInputState = _state.escAscii;\n      }\n    }\n\n    this._mLastChar = aBuf.slice(-1);\n\n    if (this._mInputState == _state.escAscii) {\n      if (!this._mEscCharsetProber) {\n        this._mEscCharsetProber = new EscCharSetProber();\n      }\n\n      if (this._mEscCharsetProber.feed(aBuf) == constants.foundIt) {\n        this.result = {\n          \"encoding\": this._mEscCharsetProber.getCharsetName(),\n          \"confidence\": this._mEscCharsetProber.getConfidence()\n        };\n        this.results = [this.result];\n        this.done = true;\n      }\n    } else if (this._mInputState == _state.highbyte) {\n      if (this._mCharsetProbers.length == 0) {\n        this._mCharsetProbers = [new MBCSGroupProber(), new SBCSGroupProber(), new Latin1Prober()];\n      }\n\n      for (var i = 0, prober; prober = this._mCharsetProbers[i]; i++) {\n        if (prober.feed(aBuf) == constants.foundIt) {\n          this.result = {\n            \"encoding\": prober.getCharsetName(),\n            \"confidence\": prober.getConfidence()\n          };\n          this.results = [this.result];\n          this.done = true;\n          break;\n        }\n      }\n    }\n  };\n\n  this.close = function () {\n    if (this.done) return;\n\n    if (this._mBOM.length === 0) {\n      logger.log(\"no data received!\\n\");\n      return;\n    }\n\n    this.done = true;\n\n    if (this._mInputState == _state.pureAscii) {\n      logger.log(\"pure ascii\");\n      this.result = {\n        \"encoding\": \"ascii\",\n        \"confidence\": 1.0\n      };\n      this.results.push(this.result);\n      return this.result;\n    }\n\n    if (this._mInputState == _state.highbyte) {\n      for (var i = 0, prober; prober = this._mCharsetProbers[i]; i++) {\n        if (!prober || !prober.getCharsetName()) continue;\n        this.results.push({\n          \"encoding\": prober.getCharsetName(),\n          \"confidence\": prober.getConfidence()\n        });\n        logger.log(prober.getCharsetName() + \" confidence \" + prober.getConfidence());\n      }\n\n      this.results.sort(function (a, b) {\n        return b.confidence - a.confidence;\n      });\n\n      if (this.results.length > 0) {\n        var topResult = this.results[0];\n\n        if (topResult.confidence >= options.minimumThreshold) {\n          this.result = topResult;\n          return topResult;\n        }\n      }\n    }\n\n    if (logger.enabled) {\n      logger.log(\"no probers hit minimum threshhold\\n\");\n\n      for (var i = 0, prober; prober = this._mCharsetProbers[i]; i++) {\n        if (!prober) continue;\n        logger.log(prober.getCharsetName() + \" confidence = \" + prober.getConfidence() + \"\\n\");\n      }\n    }\n  };\n\n  init();\n}\n\nmodule.exports = UniversalDetector;","map":{"version":3,"sources":["E:/frontend/node_modules/jschardet/src/universaldetector.js"],"names":["constants","require","MBCSGroupProber","SBCSGroupProber","Latin1Prober","EscCharSetProber","logger","UniversalDetector","options","minimumThreshold","_state","pureAscii","escAscii","highbyte","self","init","_highBitDetector","_escDetector","_mEscCharsetProber","_mCharsetProbers","reset","result","results","done","_mStart","_mGotData","_mInputState","_mLastChar","_mBOM","i","prober","feed","aBuf","aLen","length","slice","confidence","encoding","test","foundIt","getCharsetName","getConfidence","close","log","push","sort","a","b","topResult","enabled","module","exports"],"mappings":"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","sourcesContent":["/*\n * The Original Code is Mozilla Universal charset detector code.\n *\n * The Initial Developer of the Original Code is\n * Netscape Communications Corporation.\n * Portions created by the Initial Developer are Copyright (C) 2001\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *   AntÃ³nio Afonso (antonio.afonso gmail.com) - port to JavaScript\n *   Mark Pilgrim - port to Python\n *   Shy Shalom - original C code\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301  USA\n */\n\n/**\n * This is a port from the python port, version \"2.0.1\"\n */\n\nvar constants = require('./constants');\nvar MBCSGroupProber = require('./mbcsgroupprober');\nvar SBCSGroupProber = require('./sbcsgroupprober');\nvar Latin1Prober = require('./latin1prober');\nvar EscCharSetProber = require('./escprober')\nvar logger = require('./logger');\n\nfunction UniversalDetector(options) {\n    if (!options) options = {};\n    if (!options.minimumThreshold)  options.minimumThreshold = 0.20;\n\n    var _state = {\n        pureAscii   : 0,\n        escAscii    : 1,\n        highbyte    : 2\n    };\n    var self = this;\n\n    function init() {\n        self._highBitDetector = /[\\x80-\\xFF]/;\n        self._escDetector = /(\\x1B|~\\{)/;\n        self._mEscCharsetProber = null;\n        self._mCharsetProbers = [];\n        self.reset();\n    }\n\n    this.reset = function() {\n        this.result = {\"encoding\": null, \"confidence\": 0.0};\n        this.results = []\n        this.done = false;\n        this._mStart = true;\n        this._mGotData = false;\n        this._mInputState = _state.pureAscii;\n        this._mLastChar = \"\";\n        this._mBOM = \"\";\n        if( this._mEscCharsetProber ) {\n            this._mEscCharsetProber.reset();\n        }\n        for( var i = 0, prober; prober = this._mCharsetProbers[i]; i++ ) {\n            prober.reset();\n        }\n    }\n\n    this.feed = function(aBuf) {\n        if( this.done ) return;\n\n        var aLen = aBuf.length;\n        if( !aLen ) return;\n\n        if( !this._mGotData ) {\n            this._mBOM += aBuf;\n            // If the data starts with BOM, we know it is UTF\n            if( this._mBOM.slice(0,3) == \"\\xEF\\xBB\\xBF\" ) {\n                // EF BB BF  UTF-8 with BOM\n                this.result = {\"encoding\": \"UTF-8\", \"confidence\": 1.0};\n            } else if( this._mBOM.slice(0,4) == \"\\xFF\\xFE\\x00\\x00\" ) {\n                // FF FE 00 00  UTF-32, little-endian BOM\n                this.result = {\"encoding\": \"UTF-32LE\", \"confidence\": 1.0};\n            } else if( this._mBOM.slice(0,4) == \"\\x00\\x00\\xFE\\xFF\" ) {\n                // 00 00 FE FF  UTF-32, big-endian BOM\n                this.result = {\"encoding\": \"UTF-32BE\", \"confidence\": 1.0};\n            } else if( this._mBOM.slice(0,4) == \"\\xFE\\xFF\\x00\\x00\" ) {\n                // FE FF 00 00  UCS-4, unusual octet order BOM (3412)\n                this.result = {\"encoding\": \"X-ISO-10646-UCS-4-3412\", \"confidence\": 1.0};\n            } else if( this._mBOM.slice(0,4) == \"\\x00\\x00\\xFF\\xFE\" ) {\n                // 00 00 FF FE  UCS-4, unusual octet order BOM (2143)\n                this.result = {\"encoding\": \"X-ISO-10646-UCS-4-2143\", \"confidence\": 1.0};\n            } else if( this._mBOM.slice(0,2) == \"\\xFF\\xFE\" ) {\n                // FF FE  UTF-16, little endian BOM\n                this.result = {\"encoding\": \"UTF-16LE\", \"confidence\": 1.0};\n            } else if( this._mBOM.slice(0,2) == \"\\xFE\\xFF\" ) {\n                // FE FF  UTF-16, big endian BOM\n                this.result = {\"encoding\": \"UTF-16BE\", \"confidence\": 1.0};\n            }\n\n            if (this.result.confidence > 0) {\n                this.results = [this.result];\n            }\n\n            // If we got to 4 chars without being able to detect a BOM we\n            // stop trying.\n            if( this._mBOM.length > 3 ) {\n                this._mGotData = true;\n            }\n        }\n\n        if( this.result.encoding && (this.result.confidence > 0.0) ) {\n            this.done = true;\n            return;\n        }\n\n        if( this._mInputState == _state.pureAscii ) {\n            if( this._highBitDetector.test(aBuf) ) {\n                this._mInputState = _state.highbyte;\n            } else if( this._escDetector.test(this._mLastChar + aBuf) ) {\n                this._mInputState = _state.escAscii;\n            }\n        }\n\n        this._mLastChar = aBuf.slice(-1);\n\n        if( this._mInputState == _state.escAscii ) {\n            if( !this._mEscCharsetProber ) {\n                this._mEscCharsetProber = new EscCharSetProber();\n            }\n            if( this._mEscCharsetProber.feed(aBuf) == constants.foundIt ) {\n                this.result = {\n                    \"encoding\": this._mEscCharsetProber.getCharsetName(),\n                    \"confidence\": this._mEscCharsetProber.getConfidence()\n                };\n                this.results = [this.result];\n                this.done = true;\n            }\n        } else if( this._mInputState == _state.highbyte ) {\n            if( this._mCharsetProbers.length == 0 ) {\n                this._mCharsetProbers = [\n                    new MBCSGroupProber(),\n                    new SBCSGroupProber(),\n                    new Latin1Prober()\n                ];\n            }\n            for( var i = 0, prober; prober = this._mCharsetProbers[i]; i++ ) {\n                if( prober.feed(aBuf) == constants.foundIt ) {\n                    this.result = {\n                        \"encoding\": prober.getCharsetName(),\n                        \"confidence\": prober.getConfidence()\n                    };\n                    this.results = [this.result];\n                    this.done = true;\n                    break;\n                }\n            }\n        }\n    }\n\n    this.close = function() {\n        if( this.done ) return;\n        if( this._mBOM.length === 0 ) {\n            logger.log(\"no data received!\\n\");\n            return;\n        }\n        this.done = true;\n\n        if( this._mInputState == _state.pureAscii ) {\n            logger.log(\"pure ascii\")\n            this.result = {\"encoding\": \"ascii\", \"confidence\": 1.0};\n            this.results.push(this.result);\n            return this.result;\n        }\n\n        if( this._mInputState == _state.highbyte ) {\n            for( var i = 0, prober; prober = this._mCharsetProbers[i]; i++ ) {\n                if( !prober || !prober.getCharsetName()) continue;\n                this.results.push({\n                    \"encoding\": prober.getCharsetName(),\n                    \"confidence\": prober.getConfidence()\n                });\n                logger.log(prober.getCharsetName() + \" confidence \" + prober.getConfidence());\n            }\n            this.results.sort(function(a, b) {\n                return b.confidence - a.confidence;\n            });\n            if (this.results.length > 0) {\n                var topResult = this.results[0];\n                if (topResult.confidence >= options.minimumThreshold) {\n                    this.result = topResult;\n                    return topResult;\n                }\n            }\n        }\n\n        if( logger.enabled ) {\n            logger.log(\"no probers hit minimum threshhold\\n\");\n            for( var i = 0, prober; prober = this._mCharsetProbers[i]; i++ ) {\n                if( !prober ) continue;\n                logger.log(prober.getCharsetName() + \" confidence = \" +\n                    prober.getConfidence() + \"\\n\");\n            }\n        }\n    }\n\n    init();\n}\n\nmodule.exports = UniversalDetector;\n"]},"metadata":{},"sourceType":"script"}