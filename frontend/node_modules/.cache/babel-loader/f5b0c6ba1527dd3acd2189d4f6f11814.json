{"ast":null,"code":"/*\n * The Original Code is Mozilla Universal charset detector code.\n *\n * The Initial Developer of the Original Code is\n * Netscape Communications Corporation.\n * Portions created by the Initial Developer are Copyright (C) 2001\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *   António Afonso (antonio.afonso gmail.com) - port to JavaScript\n *   Mark Pilgrim - port to Python\n *   Shy Shalom - original C code\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301  USA\n */\n// This prober doesn't actually recognize a language or a charset.\n// It is a helper prober for the use of the Hebrew model probers\n////// General ideas of the Hebrew charset recognition //////\n//\n// Four main charsets exist in Hebrew:\n// \"ISO-8859-8\" - Visual Hebrew\n// \"windows-1255\" - Logical Hebrew\n// \"ISO-8859-8-I\" - Logical Hebrew\n// \"x-mac-hebrew\" - ?? Logical Hebrew ??\n//\n// Both \"ISO\" charsets use a completely identical set of code points, whereas\n// \"windows-1255\" and \"x-mac-hebrew\" are two different proper supersets of\n// these code points. windows-1255 defines additional characters in the range\n// 0x80-0x9F as some misc punctuation marks as well as some Hebrew-specific\n// diacritics and additional 'Yiddish' ligature letters in the range 0xc0-0xd6.\n// x-mac-hebrew defines similar additional code points but with a different\n// mapping.\n//\n// As far as an average Hebrew text with no diacritics is concerned, all four\n// charsets are identical with respect to code points. Meaning that for the\n// main Hebrew alphabet, all four map the same values to all 27 Hebrew letters\n// (including final letters).\n//\n// The dominant difference between these charsets is their directionality.\n// \"Visual\" directionality means that the text is ordered as if the renderer is\n// not aware of a BIDI rendering algorithm. The renderer sees the text and\n// draws it from left to right. The text itself when ordered naturally is read\n// backwards. A buffer of Visual Hebrew generally looks like so:\n// \"[last word of first line spelled backwards] [whole line ordered backwards\n// and spelled backwards] [first word of first line spelled backwards]\n// [end of line] [last word of second line] ... etc' \"\n// adding punctuation marks, numbers and English text to visual text is\n// naturally also \"visual\" and from left to right.\n//\n// \"Logical\" directionality means the text is ordered \"naturally\" according to\n// the order it is read. It is the responsibility of the renderer to display\n// the text from right to left. A BIDI algorithm is used to place general\n// punctuation marks, numbers and English text in the text.\n//\n// Texts in x-mac-hebrew are almost impossible to find on the Internet. From\n// what little evidence I could find, it seems that its general directionality\n// is Logical.\n//\n// To sum up all of the above, the Hebrew probing mechanism knows about two\n// charsets:\n// Visual Hebrew - \"ISO-8859-8\" - backwards text - Words and sentences are\n//    backwards while line order is natural. For charset recognition purposes\n//    the line order is unimportant (In fact, for this implementation, even\n//    word order is unimportant).\n// Logical Hebrew - \"windows-1255\" - normal, naturally ordered text.\n//\n// \"ISO-8859-8-I\" is a subset of windows-1255 and doesn't need to be\n//    specifically identified.\n// \"x-mac-hebrew\" is also identified as windows-1255. A text in x-mac-hebrew\n//    that contain special punctuation marks or diacritics is displayed with\n//    some unconverted characters showing as question marks. This problem might\n//    be corrected using another model prober for x-mac-hebrew. Due to the fact\n//    that x-mac-hebrew texts are so rare, writing another model prober isn't\n//    worth the effort and performance hit.\n//\n//////// The Prober ////////\n//\n// The prober is divided between two SBCharSetProbers and a HebrewProber,\n// all of which are managed, created, fed data, inquired and deleted by the\n// SBCSGroupProber. The two SBCharSetProbers identify that the text is in\n// fact some kind of Hebrew, Logical or Visual. The final decision about which\n// one is it is made by the HebrewProber by combining final-letter scores\n// with the scores of the two SBCharSetProbers to produce a final answer.\n//\n// The SBCSGroupProber is responsible for stripping the original text of HTML\n// tags, English characters, numbers, low-ASCII punctuation characters, spaces\n// and new lines. It reduces any sequence of such characters to a single space.\n// The buffer fed to each prober in the SBCS group prober is pure text in\n// high-ASCII.\n// The two SBCharSetProbers (model probers) share the same language model:\n// Win1255Model.\n// The first SBCharSetProber uses the model normally as any other\n// SBCharSetProber does, to recognize windows-1255, upon which this model was\n// built. The second SBCharSetProber is told to make the pair-of-letter\n// lookup in the language model backwards. This in practice exactly simulates\n// a visual Hebrew model using the windows-1255 logical Hebrew model.\n//\n// The HebrewProber is not using any language model. All it does is look for\n// final-letter evidence suggesting the text is either logical Hebrew or visual\n// Hebrew. Disjointed from the model probers, the results of the HebrewProber\n// alone are meaningless. HebrewProber always returns 0.00 as confidence\n// since it never identifies a charset by itself. Instead, the pointer to the\n// HebrewProber is passed to the model probers as a helper \"Name Prober\".\n// When the Group prober receives a positive identification from any prober,\n// it asks for the name of the charset identified. If the prober queried is a\n// Hebrew model prober, the model prober forwards the call to the\n// HebrewProber to make the final decision. In the HebrewProber, the\n// decision is made according to the final-letters scores maintained and Both\n// model probers scores. The answer is returned in the form of the name of the\n// charset identified, either \"windows-1255\" or \"ISO-8859-8\".\nvar CharSetProber = require('./charsetprober');\n\nvar constants = require('./constants'); // https://developer.mozilla.org/En/Core_JavaScript_1.5_Reference/Objects/Array/IndexOf\n\n\nif (!Array.prototype.indexOf) {\n  Array.prototype.indexOf = function (elt\n  /*, from*/\n  ) {\n    var len = this.length >>> 0;\n    var from = Number(arguments[1]) || 0;\n    from = from < 0 ? Math.ceil(from) : Math.floor(from);\n    if (from < 0) from += len;\n\n    for (; from < len; from++) {\n      if (from in this && this[from] === elt) return from;\n    }\n\n    return -1;\n  };\n}\n\nfunction HebrewProber() {\n  CharSetProber.apply(this); // windows-1255 / ISO-8859-8 code points of interest\n\n  var FINAL_KAF = '\\xea';\n  var NORMAL_KAF = '\\xeb';\n  var FINAL_MEM = '\\xed';\n  var NORMAL_MEM = '\\xee';\n  var FINAL_NUN = '\\xef';\n  var NORMAL_NUN = '\\xf0';\n  var FINAL_PE = '\\xf3';\n  var NORMAL_PE = '\\xf4';\n  var FINAL_TSADI = '\\xf5';\n  var NORMAL_TSADI = '\\xf6'; // Minimum Visual vs Logical final letter score difference.\n  // If the difference is below this, don't rely solely on the final letter score distance.\n\n  var MIN_FINAL_CHAR_DISTANCE = 5; // Minimum Visual vs Logical model score difference.\n  // If the difference is below this, don't rely at all on the model score distance.\n\n  var MIN_MODEL_DISTANCE = 0.01;\n  var VISUAL_HEBREW_NAME = \"ISO-8859-8\";\n  var LOGICAL_HEBREW_NAME = \"windows-1255\";\n  var self = this;\n\n  function init() {\n    self._mLogicalProber = null;\n    self._mVisualProber = null;\n    self.reset();\n  }\n\n  this.reset = function () {\n    this._mFinalCharLogicalScore = 0;\n    this._mFinalCharVisualScore = 0; // The two last characters seen in the previous buffer,\n    // mPrev and mBeforePrev are initialized to space in order to simulate a word\n    // delimiter at the beginning of the data\n\n    this._mPrev = \" \";\n    this._mBeforePrev = \" \"; // These probers are owned by the group prober.\n  };\n\n  this.setModelProbers = function (logicalProber, visualProber) {\n    this._mLogicalProber = logicalProber;\n    this._mVisualProber = visualProber;\n  };\n\n  this.isFinal = function (c) {\n    return [FINAL_KAF, FINAL_MEM, FINAL_NUN, FINAL_PE, FINAL_TSADI].indexOf(c) != -1;\n  };\n\n  this.isNonFinal = function (c) {\n    // The normal Tsadi is not a good Non-Final letter due to words like\n    // 'lechotet' (to chat) containing an apostrophe after the tsadi. This\n    // apostrophe is converted to a space in FilterWithoutEnglishLetters causing\n    // the Non-Final tsadi to appear at an end of a word even though this is not\n    // the case in the original text.\n    // The letters Pe and Kaf rarely display a related behavior of not being a\n    // good Non-Final letter. Words like 'Pop', 'Winamp' and 'Mubarak' for\n    // example legally end with a Non-Final Pe or Kaf. However, the benefit of\n    // these letters as Non-Final letters outweighs the damage since these words\n    // are quite rare.\n    return [NORMAL_KAF, NORMAL_MEM, NORMAL_NUN, NORMAL_PE].indexOf(c) != -1;\n  };\n\n  this.feed = function (aBuf) {\n    // Final letter analysis for logical-visual decision.\n    // Look for evidence that the received buffer is either logical Hebrew or\n    // visual Hebrew.\n    // The following cases are checked:\n    // 1) A word longer than 1 letter, ending with a final letter. This is an\n    //    indication that the text is laid out \"naturally\" since the final letter\n    //    really appears at the end. +1 for logical score.\n    // 2) A word longer than 1 letter, ending with a Non-Final letter. In normal\n    //    Hebrew, words ending with Kaf, Mem, Nun, Pe or Tsadi, should not end with\n    //    the Non-Final form of that letter. Exceptions to this rule are mentioned\n    //    above in isNonFinal(). This is an indication that the text is laid out\n    //    backwards. +1 for visual score\n    // 3) A word longer than 1 letter, starting with a final letter. Final letters\n    //    should not appear at the beginning of a word. This is an indication that\n    //    the text is laid out backwards. +1 for visual score.\n    //\n    // The visual score and logical score are accumulated throughout the text and\n    // are finally checked against each other in GetCharSetName().\n    // No checking for final letters in the middle of words is done since that case\n    // is not an indication for either Logical or Visual text.\n    //\n    // We automatically filter out all 7-bit characters (replace them with spaces)\n    // so the word boundary detection works properly. [MAP]\n    if (this.getState() == constants.notMe) {\n      // Both model probers say it's not them. No reason to continue.\n      return constants.notMe;\n    }\n\n    aBuf = this.filterHighBitOnly(aBuf);\n\n    for (var i = 0, cur; i < aBuf.length; i++) {\n      cur = aBuf[i];\n\n      if (cur == \" \") {\n        // We stand on a space - a word just ended\n        if (this._mBeforePrev != \" \") {\n          // next-to-last char was not a space so self._mPrev is not a 1 letter word\n          if (this.isFinal(this._mPrev)) {\n            // case (1) [-2:not space][-1:final letter][cur:space]\n            this._mFinalCharLogicalScore++;\n          } else if (this.isNonFinal(this._mPrev)) {\n            // case (2) [-2:not space][-1:Non-Final letter][cur:space]\n            this._mFinalCharVisualScore++;\n          }\n        }\n      } else {\n        // Not standing on a space\n        if (this._mBeforePrev == \" \" && this.isFinal(this._mPrev) && cur != \" \") {\n          // case (3) [-2:space][-1:final letter][cur:not space]\n          this._mFinalCharVisualScore++;\n        }\n      }\n\n      this._mBeforePrev = this._mPrev;\n      this._mPrev = cur;\n    } // Forever detecting, till the end or until both model probers return eNotMe (handled above)\n\n\n    return constants.detecting;\n  };\n\n  this.getCharsetName = function () {\n    // Make the decision: is it Logical or Visual?\n    // If the final letter score distance is dominant enough, rely on it.\n    var finalsub = this._mFinalCharLogicalScore - this._mFinalCharVisualScore;\n\n    if (finalsub >= MIN_FINAL_CHAR_DISTANCE) {\n      return LOGICAL_HEBREW_NAME;\n    }\n\n    if (finalsub <= -MIN_FINAL_CHAR_DISTANCE) {\n      return VISUAL_HEBREW_NAME;\n    } // It's not dominant enough, try to rely on the model scores instead.\n\n\n    var modelsub = this._mLogicalProber.getConfidence() - this._mVisualProber.getConfidence();\n\n    if (modelsub > MIN_MODEL_DISTANCE) {\n      return LOGICAL_HEBREW_NAME;\n    }\n\n    if (modelsub < -MIN_MODEL_DISTANCE) {\n      return VISUAL_HEBREW_NAME;\n    } // Still no good, back to final letter distance, maybe it'll save the day.\n\n\n    if (finalsub < 0) {\n      return VISUAL_HEBREW_NAME;\n    } // (finalsub > 0 - Logical) or (don't know what to do) default to Logical.\n\n\n    return LOGICAL_HEBREW_NAME;\n  };\n\n  this.getState = function () {\n    // Remain active as long as any of the model probers are active.\n    if (this._mLogicalProber.getState() == constants.notMe && this._mVisualProber.getState() == constants.notMe) {\n      return constants.notMe;\n    }\n\n    return constants.detecting;\n  };\n\n  init();\n}\n\nHebrewProber.prototype = new CharSetProber();\nmodule.exports = HebrewProber;","map":{"version":3,"sources":["D:/test/frontend/node_modules/jschardet/src/hebrewprober.js"],"names":["CharSetProber","require","constants","Array","prototype","indexOf","elt","len","length","from","Number","arguments","Math","ceil","floor","HebrewProber","apply","FINAL_KAF","NORMAL_KAF","FINAL_MEM","NORMAL_MEM","FINAL_NUN","NORMAL_NUN","FINAL_PE","NORMAL_PE","FINAL_TSADI","NORMAL_TSADI","MIN_FINAL_CHAR_DISTANCE","MIN_MODEL_DISTANCE","VISUAL_HEBREW_NAME","LOGICAL_HEBREW_NAME","self","init","_mLogicalProber","_mVisualProber","reset","_mFinalCharLogicalScore","_mFinalCharVisualScore","_mPrev","_mBeforePrev","setModelProbers","logicalProber","visualProber","isFinal","c","isNonFinal","feed","aBuf","getState","notMe","filterHighBitOnly","i","cur","detecting","getCharsetName","finalsub","modelsub","getConfidence","module","exports"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,IAAIA,aAAa,GAAGC,OAAO,CAAC,iBAAD,CAA3B;;AACA,IAAIC,SAAS,GAAGD,OAAO,CAAC,aAAD,CAAvB,C,CAEA;;;AACA,IAAI,CAACE,KAAK,CAACC,SAAN,CAAgBC,OAArB,EACA;AACIF,EAAAA,KAAK,CAACC,SAAN,CAAgBC,OAAhB,GAA0B,UAASC;AAAI;AAAb,IAC1B;AACI,QAAIC,GAAG,GAAG,KAAKC,MAAL,KAAgB,CAA1B;AAEA,QAAIC,IAAI,GAAGC,MAAM,CAACC,SAAS,CAAC,CAAD,CAAV,CAAN,IAAwB,CAAnC;AACAF,IAAAA,IAAI,GAAIA,IAAI,GAAG,CAAR,GACAG,IAAI,CAACC,IAAL,CAAUJ,IAAV,CADA,GAEAG,IAAI,CAACE,KAAL,CAAWL,IAAX,CAFP;AAGA,QAAIA,IAAI,GAAG,CAAX,EACIA,IAAI,IAAIF,GAAR;;AAEJ,WAAOE,IAAI,GAAGF,GAAd,EAAmBE,IAAI,EAAvB,EACA;AACI,UAAIA,IAAI,IAAI,IAAR,IACA,KAAKA,IAAL,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","sourcesContent":["/*\n * The Original Code is Mozilla Universal charset detector code.\n *\n * The Initial Developer of the Original Code is\n * Netscape Communications Corporation.\n * Portions created by the Initial Developer are Copyright (C) 2001\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *   António Afonso (antonio.afonso gmail.com) - port to JavaScript\n *   Mark Pilgrim - port to Python\n *   Shy Shalom - original C code\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301  USA\n */\n\n// This prober doesn't actually recognize a language or a charset.\n// It is a helper prober for the use of the Hebrew model probers\n\n////// General ideas of the Hebrew charset recognition //////\n//\n// Four main charsets exist in Hebrew:\n// \"ISO-8859-8\" - Visual Hebrew\n// \"windows-1255\" - Logical Hebrew\n// \"ISO-8859-8-I\" - Logical Hebrew\n// \"x-mac-hebrew\" - ?? Logical Hebrew ??\n//\n// Both \"ISO\" charsets use a completely identical set of code points, whereas\n// \"windows-1255\" and \"x-mac-hebrew\" are two different proper supersets of\n// these code points. windows-1255 defines additional characters in the range\n// 0x80-0x9F as some misc punctuation marks as well as some Hebrew-specific\n// diacritics and additional 'Yiddish' ligature letters in the range 0xc0-0xd6.\n// x-mac-hebrew defines similar additional code points but with a different\n// mapping.\n//\n// As far as an average Hebrew text with no diacritics is concerned, all four\n// charsets are identical with respect to code points. Meaning that for the\n// main Hebrew alphabet, all four map the same values to all 27 Hebrew letters\n// (including final letters).\n//\n// The dominant difference between these charsets is their directionality.\n// \"Visual\" directionality means that the text is ordered as if the renderer is\n// not aware of a BIDI rendering algorithm. The renderer sees the text and\n// draws it from left to right. The text itself when ordered naturally is read\n// backwards. A buffer of Visual Hebrew generally looks like so:\n// \"[last word of first line spelled backwards] [whole line ordered backwards\n// and spelled backwards] [first word of first line spelled backwards]\n// [end of line] [last word of second line] ... etc' \"\n// adding punctuation marks, numbers and English text to visual text is\n// naturally also \"visual\" and from left to right.\n//\n// \"Logical\" directionality means the text is ordered \"naturally\" according to\n// the order it is read. It is the responsibility of the renderer to display\n// the text from right to left. A BIDI algorithm is used to place general\n// punctuation marks, numbers and English text in the text.\n//\n// Texts in x-mac-hebrew are almost impossible to find on the Internet. From\n// what little evidence I could find, it seems that its general directionality\n// is Logical.\n//\n// To sum up all of the above, the Hebrew probing mechanism knows about two\n// charsets:\n// Visual Hebrew - \"ISO-8859-8\" - backwards text - Words and sentences are\n//    backwards while line order is natural. For charset recognition purposes\n//    the line order is unimportant (In fact, for this implementation, even\n//    word order is unimportant).\n// Logical Hebrew - \"windows-1255\" - normal, naturally ordered text.\n//\n// \"ISO-8859-8-I\" is a subset of windows-1255 and doesn't need to be\n//    specifically identified.\n// \"x-mac-hebrew\" is also identified as windows-1255. A text in x-mac-hebrew\n//    that contain special punctuation marks or diacritics is displayed with\n//    some unconverted characters showing as question marks. This problem might\n//    be corrected using another model prober for x-mac-hebrew. Due to the fact\n//    that x-mac-hebrew texts are so rare, writing another model prober isn't\n//    worth the effort and performance hit.\n//\n//////// The Prober ////////\n//\n// The prober is divided between two SBCharSetProbers and a HebrewProber,\n// all of which are managed, created, fed data, inquired and deleted by the\n// SBCSGroupProber. The two SBCharSetProbers identify that the text is in\n// fact some kind of Hebrew, Logical or Visual. The final decision about which\n// one is it is made by the HebrewProber by combining final-letter scores\n// with the scores of the two SBCharSetProbers to produce a final answer.\n//\n// The SBCSGroupProber is responsible for stripping the original text of HTML\n// tags, English characters, numbers, low-ASCII punctuation characters, spaces\n// and new lines. It reduces any sequence of such characters to a single space.\n// The buffer fed to each prober in the SBCS group prober is pure text in\n// high-ASCII.\n// The two SBCharSetProbers (model probers) share the same language model:\n// Win1255Model.\n// The first SBCharSetProber uses the model normally as any other\n// SBCharSetProber does, to recognize windows-1255, upon which this model was\n// built. The second SBCharSetProber is told to make the pair-of-letter\n// lookup in the language model backwards. This in practice exactly simulates\n// a visual Hebrew model using the windows-1255 logical Hebrew model.\n//\n// The HebrewProber is not using any language model. All it does is look for\n// final-letter evidence suggesting the text is either logical Hebrew or visual\n// Hebrew. Disjointed from the model probers, the results of the HebrewProber\n// alone are meaningless. HebrewProber always returns 0.00 as confidence\n// since it never identifies a charset by itself. Instead, the pointer to the\n// HebrewProber is passed to the model probers as a helper \"Name Prober\".\n// When the Group prober receives a positive identification from any prober,\n// it asks for the name of the charset identified. If the prober queried is a\n// Hebrew model prober, the model prober forwards the call to the\n// HebrewProber to make the final decision. In the HebrewProber, the\n// decision is made according to the final-letters scores maintained and Both\n// model probers scores. The answer is returned in the form of the name of the\n// charset identified, either \"windows-1255\" or \"ISO-8859-8\".\n\nvar CharSetProber = require('./charsetprober');\nvar constants = require('./constants')\n\n// https://developer.mozilla.org/En/Core_JavaScript_1.5_Reference/Objects/Array/IndexOf\nif (!Array.prototype.indexOf)\n{\n    Array.prototype.indexOf = function(elt /*, from*/)\n    {\n        var len = this.length >>> 0;\n\n        var from = Number(arguments[1]) || 0;\n        from = (from < 0)\n             ? Math.ceil(from)\n             : Math.floor(from);\n        if (from < 0)\n            from += len;\n\n        for (; from < len; from++)\n        {\n            if (from in this &&\n                this[from] === elt)\n                return from;\n        }\n        return -1;\n    };\n}\n\nfunction HebrewProber() {\n    CharSetProber.apply(this);\n\n    // windows-1255 / ISO-8859-8 code points of interest\n    var FINAL_KAF = '\\xea'\n    var NORMAL_KAF = '\\xeb'\n    var FINAL_MEM = '\\xed'\n    var NORMAL_MEM = '\\xee'\n    var FINAL_NUN = '\\xef'\n    var NORMAL_NUN = '\\xf0'\n    var FINAL_PE = '\\xf3'\n    var NORMAL_PE = '\\xf4'\n    var FINAL_TSADI = '\\xf5'\n    var NORMAL_TSADI = '\\xf6'\n\n    // Minimum Visual vs Logical final letter score difference.\n    // If the difference is below this, don't rely solely on the final letter score distance.\n    var MIN_FINAL_CHAR_DISTANCE = 5\n\n    // Minimum Visual vs Logical model score difference.\n    // If the difference is below this, don't rely at all on the model score distance.\n    var MIN_MODEL_DISTANCE = 0.01\n\n    var VISUAL_HEBREW_NAME = \"ISO-8859-8\"\n    var LOGICAL_HEBREW_NAME = \"windows-1255\"\n    var self = this;\n\n    function init() {\n        self._mLogicalProber = null;\n        self._mVisualProber = null;\n        self.reset();\n    }\n\n    this.reset = function() {\n        this._mFinalCharLogicalScore = 0;\n        this._mFinalCharVisualScore = 0;\n        // The two last characters seen in the previous buffer,\n        // mPrev and mBeforePrev are initialized to space in order to simulate a word\n        // delimiter at the beginning of the data\n        this._mPrev = \" \";\n        this._mBeforePrev = \" \";\n        // These probers are owned by the group prober.\n    }\n\n    this.setModelProbers = function(logicalProber, visualProber) {\n        this._mLogicalProber = logicalProber;\n        this._mVisualProber = visualProber;\n    }\n\n    this.isFinal = function(c) {\n        return [FINAL_KAF, FINAL_MEM, FINAL_NUN, FINAL_PE, FINAL_TSADI].indexOf(c) != -1;\n    }\n\n    this.isNonFinal = function(c) {\n        // The normal Tsadi is not a good Non-Final letter due to words like\n        // 'lechotet' (to chat) containing an apostrophe after the tsadi. This\n        // apostrophe is converted to a space in FilterWithoutEnglishLetters causing\n        // the Non-Final tsadi to appear at an end of a word even though this is not\n        // the case in the original text.\n        // The letters Pe and Kaf rarely display a related behavior of not being a\n        // good Non-Final letter. Words like 'Pop', 'Winamp' and 'Mubarak' for\n        // example legally end with a Non-Final Pe or Kaf. However, the benefit of\n        // these letters as Non-Final letters outweighs the damage since these words\n        // are quite rare.\n        return [NORMAL_KAF, NORMAL_MEM, NORMAL_NUN, NORMAL_PE].indexOf(c) != -1;\n    }\n\n    this.feed = function(aBuf) {\n        // Final letter analysis for logical-visual decision.\n        // Look for evidence that the received buffer is either logical Hebrew or\n        // visual Hebrew.\n        // The following cases are checked:\n        // 1) A word longer than 1 letter, ending with a final letter. This is an\n        //    indication that the text is laid out \"naturally\" since the final letter\n        //    really appears at the end. +1 for logical score.\n        // 2) A word longer than 1 letter, ending with a Non-Final letter. In normal\n        //    Hebrew, words ending with Kaf, Mem, Nun, Pe or Tsadi, should not end with\n        //    the Non-Final form of that letter. Exceptions to this rule are mentioned\n        //    above in isNonFinal(). This is an indication that the text is laid out\n        //    backwards. +1 for visual score\n        // 3) A word longer than 1 letter, starting with a final letter. Final letters\n        //    should not appear at the beginning of a word. This is an indication that\n        //    the text is laid out backwards. +1 for visual score.\n        //\n        // The visual score and logical score are accumulated throughout the text and\n        // are finally checked against each other in GetCharSetName().\n        // No checking for final letters in the middle of words is done since that case\n        // is not an indication for either Logical or Visual text.\n        //\n        // We automatically filter out all 7-bit characters (replace them with spaces)\n        // so the word boundary detection works properly. [MAP]\n\n        if( this.getState() == constants.notMe ) {\n            // Both model probers say it's not them. No reason to continue.\n            return constants.notMe;\n        }\n\n        aBuf = this.filterHighBitOnly(aBuf);\n\n        for( var i = 0, cur; i < aBuf.length; i++ ) {\n            cur = aBuf[i];\n            if( cur == \" \" ) {\n                // We stand on a space - a word just ended\n                if( this._mBeforePrev != \" \" ) {\n                    // next-to-last char was not a space so self._mPrev is not a 1 letter word\n                    if( this.isFinal(this._mPrev) ) {\n                        // case (1) [-2:not space][-1:final letter][cur:space]\n                        this._mFinalCharLogicalScore++;\n                    } else if( this.isNonFinal(this._mPrev) ) {\n                        // case (2) [-2:not space][-1:Non-Final letter][cur:space]\n                        this._mFinalCharVisualScore++;\n                    }\n                }\n            } else {\n                // Not standing on a space\n                if( this._mBeforePrev == \" \" && this.isFinal(this._mPrev) && cur != \" \" ) {\n                    // case (3) [-2:space][-1:final letter][cur:not space]\n                    this._mFinalCharVisualScore++;\n                }\n            }\n            this._mBeforePrev = this._mPrev;\n            this._mPrev = cur;\n        }\n        // Forever detecting, till the end or until both model probers return eNotMe (handled above)\n        return constants.detecting;\n    }\n\n    this.getCharsetName = function() {\n        // Make the decision: is it Logical or Visual?\n        // If the final letter score distance is dominant enough, rely on it.\n        var finalsub = this._mFinalCharLogicalScore - this._mFinalCharVisualScore;\n        if( finalsub >= MIN_FINAL_CHAR_DISTANCE ) {\n            return LOGICAL_HEBREW_NAME;\n        }\n        if( finalsub <= -MIN_FINAL_CHAR_DISTANCE ) {\n            return VISUAL_HEBREW_NAME;\n        }\n\n        // It's not dominant enough, try to rely on the model scores instead.\n        var modelsub = this._mLogicalProber.getConfidence() - this._mVisualProber.getConfidence();\n        if( modelsub > MIN_MODEL_DISTANCE ) {\n            return LOGICAL_HEBREW_NAME;\n        }\n        if( modelsub < -MIN_MODEL_DISTANCE ) {\n            return VISUAL_HEBREW_NAME;\n        }\n\n        // Still no good, back to final letter distance, maybe it'll save the day.\n        if( finalsub < 0 ) {\n            return VISUAL_HEBREW_NAME;\n        }\n\n        // (finalsub > 0 - Logical) or (don't know what to do) default to Logical.\n        return LOGICAL_HEBREW_NAME;\n    }\n\n    this.getState = function() {\n        // Remain active as long as any of the model probers are active.\n        if( this._mLogicalProber.getState() == constants.notMe &&\n            this._mVisualProber.getState() == constants.notMe ) {\n            return constants.notMe;\n        }\n        return constants.detecting;\n    }\n\n    init();\n}\nHebrewProber.prototype = new CharSetProber();\n\nmodule.exports = HebrewProber\n"]},"metadata":{},"sourceType":"script"}