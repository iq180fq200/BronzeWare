{"ast":null,"code":"/*\n * The Original Code is Mozilla Universal charset detector code.\n *\n * The Initial Developer of the Original Code is\n * Netscape Communications Corporation.\n * Portions created by the Initial Developer are Copyright (C) 2001\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *   António Afonso (antonio.afonso gmail.com) - port to JavaScript\n *   Mark Pilgrim - port to Python\n *   Shy Shalom - original C code\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301  USA\n */\nvar CharSetProber = require('./charsetprober');\n\nvar constants = require('./constants');\n\nvar logger = require('./logger');\n\nfunction SingleByteCharSetProber(model, reversed, nameProber) {\n  CharSetProber.apply(this);\n  var SAMPLE_SIZE = 64;\n  var SB_ENOUGH_REL_THRESHOLD = 1024;\n  var POSITIVE_SHORTCUT_THRESHOLD = 0.95;\n  var NEGATIVE_SHORTCUT_THRESHOLD = 0.05;\n  var SYMBOL_CAT_ORDER = 250;\n  var NUMBER_OF_SEQ_CAT = 4;\n  var POSITIVE_CAT = NUMBER_OF_SEQ_CAT - 1; //var NEGATIVE_CAT = 0;\n\n  var self = this;\n\n  function init(model, reversed, nameProber) {\n    self._mModel = model;\n    self._mReversed = reversed; // \"true\" if we need to reverse every pair in the model lookup\n\n    self._mNameProber = nameProber; // Optional auxiliary prober for name decision\n\n    self.reset();\n  }\n\n  this.reset = function () {\n    SingleByteCharSetProber.prototype.reset.apply(this);\n    this._mLastOrder = 255; // char order of last character\n\n    this._mSeqCounters = [];\n\n    for (var i = 0; i < NUMBER_OF_SEQ_CAT; this._mSeqCounters[i++] = 0);\n\n    this._mTotalSeqs = 0;\n    this._mTotalChar = 0;\n    this._mFreqChar = 0; // characters that fall in our sampling range\n  };\n\n  this.getCharsetName = function () {\n    if (this._mNameProber) {\n      return this._mNameProber.getCharsetName();\n    } else {\n      return this._mModel.charsetName;\n    }\n  };\n\n  this.feed = function (aBuf) {\n    if (!this._mModel.keepEnglishLetter) {\n      aBuf = this.filterWithoutEnglishLetters(aBuf);\n    }\n\n    var aLen = aBuf.length;\n\n    if (!aLen) {\n      return this.getState();\n    }\n\n    for (var i = 0, c; i < aLen; i++) {\n      c = aBuf.charCodeAt(i);\n      var order = this._mModel.charToOrderMap[c];\n\n      if (order < SYMBOL_CAT_ORDER) {\n        this._mTotalChar++;\n      }\n\n      if (order < SAMPLE_SIZE) {\n        this._mFreqChar++;\n\n        if (this._mLastOrder < SAMPLE_SIZE) {\n          this._mTotalSeqs++;\n\n          if (!this._mReversed) {\n            this._mSeqCounters[this._mModel.precedenceMatrix[this._mLastOrder * SAMPLE_SIZE + order]]++;\n          } else {\n            // reverse the order of the letters in the lookup\n            this._mSeqCounters[this._mModel.precedenceMatrix[order * SAMPLE_SIZE + this._mLastOrder]]++;\n          }\n        }\n      }\n\n      this._mLastOrder = order;\n    }\n\n    if (this.getState() == constants.detecting) {\n      if (self._mTotalSeqs > SB_ENOUGH_REL_THRESHOLD) {\n        var cf = this.getConfidence();\n\n        if (cf > POSITIVE_SHORTCUT_THRESHOLD) {\n          logger.log(this._mModel.charsetName + \" confidence = \" + cf + \", we have a winner\\n\");\n        } else if (cf < NEGATIVE_SHORTCUT_THRESHOLD) {\n          logger.log(this._mModel.charsetName + \" confidence = \" + cf + \", below negative shortcut threshhold \" + NEGATIVE_SHORTCUT_THRESHOLD + \"\\n\");\n          this._mState = constants.notMe;\n        }\n      }\n    }\n\n    return this.getState();\n  };\n\n  this.getConfidence = function () {\n    var r = 0.01;\n\n    if (this._mTotalSeqs > 0) {\n      //logger.log(this._mSeqCounters[POSITIVE_CAT] + \" \" + this._mTotalSeqs + \" \" + this._mModel.mTypicalPositiveRatio);\n      r = 1.0 * this._mSeqCounters[POSITIVE_CAT] / this._mTotalSeqs / this._mModel.mTypicalPositiveRatio; //logger.log(r + \" \" + this._mFreqChar + \" \" + this._mTotalChar);\n\n      r *= this._mFreqChar / this._mTotalChar;\n\n      if (r >= 1.0) {\n        r = 0.99;\n      }\n    }\n\n    return r;\n  };\n\n  reversed = reversed !== undefined ? reversed : false;\n  nameProber = nameProber !== undefined ? nameProber : null;\n  init(model, reversed, nameProber);\n}\n\nSingleByteCharSetProber.prototype = new CharSetProber();\nmodule.exports = SingleByteCharSetProber;","map":{"version":3,"sources":["E:/frontend/node_modules/jschardet/src/sbcharsetprober.js"],"names":["CharSetProber","require","constants","logger","SingleByteCharSetProber","model","reversed","nameProber","apply","SAMPLE_SIZE","SB_ENOUGH_REL_THRESHOLD","POSITIVE_SHORTCUT_THRESHOLD","NEGATIVE_SHORTCUT_THRESHOLD","SYMBOL_CAT_ORDER","NUMBER_OF_SEQ_CAT","POSITIVE_CAT","self","init","_mModel","_mReversed","_mNameProber","reset","prototype","_mLastOrder","_mSeqCounters","i","_mTotalSeqs","_mTotalChar","_mFreqChar","getCharsetName","charsetName","feed","aBuf","keepEnglishLetter","filterWithoutEnglishLetters","aLen","length","getState","c","charCodeAt","order","charToOrderMap","precedenceMatrix","detecting","cf","getConfidence","log","_mState","notMe","r","mTypicalPositiveRatio","undefined","module","exports"],"mappings":"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","sourcesContent":["/*\n * The Original Code is Mozilla Universal charset detector code.\n *\n * The Initial Developer of the Original Code is\n * Netscape Communications Corporation.\n * Portions created by the Initial Developer are Copyright (C) 2001\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *   António Afonso (antonio.afonso gmail.com) - port to JavaScript\n *   Mark Pilgrim - port to Python\n *   Shy Shalom - original C code\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301  USA\n */\n\nvar CharSetProber = require('./charsetprober');\nvar constants = require('./constants');\nvar logger = require('./logger');\n\nfunction SingleByteCharSetProber(model, reversed, nameProber) {\n    CharSetProber.apply(this);\n\n    var SAMPLE_SIZE = 64;\n    var SB_ENOUGH_REL_THRESHOLD = 1024;\n    var POSITIVE_SHORTCUT_THRESHOLD = 0.95;\n    var NEGATIVE_SHORTCUT_THRESHOLD = 0.05;\n    var SYMBOL_CAT_ORDER = 250;\n    var NUMBER_OF_SEQ_CAT = 4;\n    var POSITIVE_CAT = NUMBER_OF_SEQ_CAT - 1;\n    //var NEGATIVE_CAT = 0;\n\n    var self = this;\n\n    function init(model, reversed, nameProber) {\n        self._mModel = model;\n        self._mReversed = reversed; // \"true\" if we need to reverse every pair in the model lookup\n        self._mNameProber = nameProber; // Optional auxiliary prober for name decision\n        self.reset();\n    }\n\n    this.reset = function() {\n        SingleByteCharSetProber.prototype.reset.apply(this);\n        this._mLastOrder = 255; // char order of last character\n        this._mSeqCounters = [];\n        for( var i = 0; i < NUMBER_OF_SEQ_CAT; this._mSeqCounters[i++] = 0 );\n        this._mTotalSeqs = 0;\n        this._mTotalChar = 0;\n        this._mFreqChar = 0; // characters that fall in our sampling range\n    }\n\n    this.getCharsetName = function() {\n        if( this._mNameProber ) {\n            return this._mNameProber.getCharsetName();\n        } else {\n            return this._mModel.charsetName;\n        }\n    }\n\n    this.feed = function(aBuf) {\n        if( ! this._mModel.keepEnglishLetter ) {\n            aBuf = this.filterWithoutEnglishLetters(aBuf);\n        }\n        var aLen = aBuf.length;\n        if( !aLen ) {\n            return this.getState();\n        }\n        for( var i = 0, c; i < aLen; i++ )\n        {\n            c = aBuf.charCodeAt(i);\n            var order = this._mModel.charToOrderMap[c];\n            if( order < SYMBOL_CAT_ORDER ) {\n                this._mTotalChar++;\n            }\n            if( order < SAMPLE_SIZE ) {\n                this._mFreqChar++;\n                if( this._mLastOrder < SAMPLE_SIZE ) {\n                    this._mTotalSeqs++;\n                    if( !this._mReversed ) {\n                        this._mSeqCounters[this._mModel.precedenceMatrix[(this._mLastOrder * SAMPLE_SIZE) + order]]++;\n                    } else { // reverse the order of the letters in the lookup\n                        this._mSeqCounters[this._mModel.precedenceMatrix[(order * SAMPLE_SIZE) + this._mLastOrder]]++;\n                    }\n                }\n            }\n            this._mLastOrder = order;\n        }\n\n        if( this.getState() == constants.detecting ) {\n            if( self._mTotalSeqs > SB_ENOUGH_REL_THRESHOLD ) {\n                var cf = this.getConfidence();\n                if( cf > POSITIVE_SHORTCUT_THRESHOLD ) {\n                    logger.log(this._mModel.charsetName + \" confidence = \" + cf + \", we have a winner\\n\");\n                } else if( cf < NEGATIVE_SHORTCUT_THRESHOLD ) {\n                    logger.log(this._mModel.charsetName + \" confidence = \" + cf + \", below negative shortcut threshhold \" + NEGATIVE_SHORTCUT_THRESHOLD + \"\\n\");\n                    this._mState = constants.notMe;\n                }\n            }\n        }\n\n        return this.getState();\n    }\n\n    this.getConfidence = function() {\n        var r = 0.01;\n        if( this._mTotalSeqs > 0 ) {\n            //logger.log(this._mSeqCounters[POSITIVE_CAT] + \" \" + this._mTotalSeqs + \" \" + this._mModel.mTypicalPositiveRatio);\n            r = (1.0 * this._mSeqCounters[POSITIVE_CAT]) / this._mTotalSeqs / this._mModel.mTypicalPositiveRatio;\n            //logger.log(r + \" \" + this._mFreqChar + \" \" + this._mTotalChar);\n            r *= this._mFreqChar / this._mTotalChar;\n            if( r >= 1.0 ) {\n                r = 0.99;\n            }\n        }\n        return r;\n    }\n\n    reversed = reversed !== undefined ? reversed : false;\n    nameProber = nameProber !== undefined ? nameProber : null;\n    init(model, reversed, nameProber);\n}\nSingleByteCharSetProber.prototype = new CharSetProber();\n\nmodule.exports = SingleByteCharSetProber\n"]},"metadata":{},"sourceType":"script"}